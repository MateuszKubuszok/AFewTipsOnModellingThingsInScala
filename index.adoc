= A few tips on modelling things in Scala


== About me

[%step]
* breaking things in Scala for 5+ years
* breaking things for money for 8 years
* breaking things for fun for 16(?) years
* blog at https://kubuszok.com[kubuszok.com]
* niche https://leanpub.com/jvm-scala-book[Things you need to know about JVM (that matter in Scala)] ebook


== The plan

[%step]
* `case class` es - when, when not
* flat is (often) bad
* `sealed trait` s - not only enums
* one size suit all - doesn't work
* integrations and derivation



== `case class` es

=== Warm up

What we get when we do?

[source, scala]
--
case class Value(a: Int, b: String)
--

=== !

[source, scala]
--
class Value(a: Int, b: String)
    extends Product with Serializable {
  def copy(a: Int = a, b: String = b): Value = ...
  override def equals(obj: AnyRef): Boolean = ...
  override def hashCode(): Int = ...
  override def toString(): String = s"Value($a, $b)"
  // ... a lot of methods from Product
}
object Value extends ((Int, String) => Value) {
  def apply(a: Int, b: String): Value = new Value(a, b)
  def unapply(value: Value): Option[(Int, String)] = ...
}
--

=== !

[source, scala]
--
Value(1, "1") == new Value(1, "1") // true
Value(1, "1") == Value(2, "2") // false
Value(1, "1") == Value(1, "2").copy(b = "1") // true

Value(1, "1") match {
  case Value(a, b) => println(s"a: $a, b: $b")
}
--

=== When

[%step]
* we want to represent a value/record
* **all** properties are value types

=== When not

=== !

When there is state

[.fragment]
[source, scala]
--
case class NamedCounter(name: String,
                        var counter: Int = 0) {
  def action(): Unit = counter += 1
}
--

[.fragment]
[source, scala]
--
val counter  = NamedCounter("test")
val counters = scala.collection.immutable.HashSet(counter)
counters(counter) // true
counter.action()
counters(counter) // false
--

[.fragment]
[source, scala]
--
class NamedCounter(val name: String) {
  var counter: Int = 0
  def action(): Unit = counter += 1
}
--

[NOTE.speaker]
--
Value types shouldn't be stateful.
--

=== !

When class describes behavior - especially side effects

[.fragment]
[source, scala]
--
case class DbConnection(user: String,
                        pass: String,
                        url: String) {
  // perhaps initialize connection?
  def runSql(query: String): Int = ...
}
--

[.fragment]
[source, scala]
--
case class DbConfig(user: String,
                    pass: String,
                    url: String)

class DbConnection(dbCfg: DbConfig) {
  // behavior
}
--

[NOTE.speaker]
--
Value types aren't behavior. Generating apply doesn't justify using `case class`.
--

=== !

When not all properties are values

[.fragment]
[source, scala]
--
case class KeyPair(publicKey: Array[Byte],
                   privateKey: Array[Byte])
--

[.fragment]
[source, scala]
--
case class KeyPair(publicKey: ArraySeq[Byte],
                   privateKey: ArraySeq[Byte])
--

[NOTE.speaker]
--
Don't put into `case class` values which doesn't implement safe `equals` and `hashCode`. If you imagine nested `case class` es as a tree, all leafs have to have sane implementations.
--

=== Cats Typeclasses

[%step]
* *default* `Eq` should match `.equals`
* do not use `Show` for any business logic, only debugging (same for `.toString`)

[NOTE.speaker]
--
These are my own recommendations.
--


== Flat is (often) bad

=== Flat entity

[source, scala]
--
case class UserAddress(
  id:           UUID,
  userID:       UUID,
  addressLine1: String,
  addressLine2: Option[String],
  city:         String,
  zipCode:      String
)
--

=== Comparison

[source, scala]
--
// check for the same entity and version
address1 == address2

// check for the same entity, maybe different version
address1.id == address2.id

// check for the same address value, maybe different entity
(address1.addressLine1 == address2.addressLine1) &&
  (address1.addressLine2 == address2.addressLine2) &&
  (address1.city == address2.city) &&
  (address1.zipCode == address2.zipCode)
--

[NOTE.speaker]
--
What if you add a new field? Do we remember to update all places? Does the code tells us what we do business-wise?
--

=== Just data things

[source, scala]
--
case class DataRecord(
  name1: String,
  name2: String,
  yetAnotherName: String,
  // ... 20-30 fields more
  metricX: Int,
  metricY: Int
)
--

[NOTE.speaker]
--
Grouping these values into smaller values would help structural sharing on update, passing on only the part that is needed but more importantly
--

=== Nested entity

[source, scala]
--
final case class UserAddress(
  id:   UserAddress.ID,
  data: UserAddress.Data)
object UserAddress {
  type ID = UUID // or AnyVal or tagged or @newtype
  final case class Data(
    userID:  User.ID,
    address: Address)
}
final case class Address(
  addressLine1: String, // other candidates for:
  addressLine2: Option[String], // * type aliases
  city:         String,         // * AnyVals or
  zipCode:      String)         // * @newtypes
--

=== Comparison again

[source, scala]
--
userAddress1 == userAddress2

userAddress1.id == userAddress2.id

userAddress1.data.userID == userAddress2.data.userID

userAddress1.data.address == userAddress2.data.address
--

[NOTE.speaker]
--
Intent is self-evident. `===` and `Eq` can work even better.
--

=== Why people avoid nesting

[.fragment]
Because `.copy`

[.fragment]
[source, scala]
--
userAddress.copy(
  data = userAddress.data.copy(
    address = userAddress.data.address.copy(city = "Yolo")
  )
)
--

[.fragment]
Unnecessarily

[.fragment]
[source, scala]
--
import com.softwaremill.quicklens._ // \o/ \o/ \o/

userAddress.modify(_.data.address).setTo("Yolo")
userAddress.modify(_.data.address).using(_.toUppercase)
--


== `sealed trait` s

=== Enums

[source, scala]
--
sealed trait Color
object Color {
  case object Red extends Color
  case object Blue extends Color
  case object Green extends Color
}
--

[source, scala]
--
(color: Color) match {
  case Color.Red   =>
  case Color.Blue  =>
  case Color.Green =>
}
--

[NOTE.speaker]
--
Exhaustivity check. Enums like that can be improved with Enumeratum. Avoid Enumerations!
--

=== Enumerating valid combinations

[.fragment]
[source, scala]
--
case class UserEmail(currentEmail: String,
                     newEmail:     Option[String] = None,
                     confirmed:    Boolean        = false)
--

[.fragment]
[source, scala]
--
sealed trait UserEmail
object UserEmail {
  case class New(email: String) extends UserEmail
  case class Confirmed(email: String) extends UserEmail
  case class Changing(currentEmail: String,
                      newEmail: String) extends UserEmail
}
--

[NOTE.speaker]
--
Eliminate options and explosion of combinations.
--

=== !

If `sealed trait` doesn't work for some reason

[source, scala]
--
sealed abstract case class UserEmail private (
  currentEmail: String,
  newEmail:     Option[String],
  confirmed:    Boolean
)
object UserEmail {
  def parse(
    currentEmail: String,
    newEmail:     Option[String] = None,
    confirmed:    Boolean        = false
  ): Either[String, UserEmail] =
    if (/* validation */) Right(new UserEmail(...) {})
    else Left("Illegal combination of parameters")
}
--

[NOTE.speaker]
--
Smart constructor.
`abstract` prevents `.copy` and `.apply`.
`private` prevent `new` outside of this object.
`sealed` prevents `extends`.
`.equals`, `.hashCode`, `.toString` and `unapply` still works.
A lot of cases that used to be handled by smart constructor are handled by Refine Types.
--


== A case against uniform modelling

[.fragment]
Uniform modelling:

[%step]
* design a model
* use if for business logic
* and persistence
* and API

[NOTE.speaker]
--
Taking a moment to design a model that is simple to understand and hard to use wrong.
--


== Integrations


== Questons?


== Thank you!
